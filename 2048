#!/usr/bin/env bash

# ---
# functions
# ---

color ()
{
    c=0

    for a in 4{0..5} 10{0..5}; do
        ((c == $1)) && # get corresponding color
            printf "%b%4s%b" "\\e[${a}m" "$1" "\\e[0m"

        ((c = c ? c * 2 : 2))
    done
}

new ()
{
    ((x = RANDOM % 4, y = RANDOM % 4))

    # generate a brand new cell
    while ((g[$x $y])); do
        ((x = RANDOM % 4, y = RANDOM % 4))
    done

    g[$x $y]=2
}

check ()
{
    c=0

    for i in {0..3}\ {0..3}; do
        ((g[$i] && c++, g[$i] == 2048)) && exit
    done

    ((c == 16)) && exit
}

display ()
{
    # print in place
    printf "\\e[H"

    for i in {0..3}\ {0..3}; do
        color "${g[$i]}"
        ((${i#?} == 3)) && printf "\\n"
    done
}

push ()
{
    case $1 in
        h)
            for i in {0..3}; do
                for j in {0..3}; do
                    for ((k = j + 1; k < 4; k++)) do
                        ((g[$i $j] == g[$i $k] && (g[$i $j] += g[$i $k], g[$i $k] = 0))) && break
                    done
                done
            done

            for i in {0..3}; do
                for j in {0..3}; do
                    if ((! g[$i $j])); then
                        for ((k = j + 1; k < 4; k++)) do
                            ((g[$i $k])) && break
                        done

                        ((g[$i $j] = g[$i $k], g[$i $k] = 0))
                    fi
                done
            done
            ;;
        k)
            for i in {0..3}; do
                for j in {0..3}; do
                    for ((k = j + 1; k < 4; k++)) do
                        ((g[$j $i] == g[$k $i] && (g[$j $i] += g[$k $i], g[$k $i] = 0))) && break
                    done
                done
            done

            for i in {0..3}; do
                for j in {0..3}; do
                    if ((! g[$j $i])); then
                        for ((k = j + 1; k < 4; k++)) do
                            ((g[$k $i])) && break
                        done

                        ((g[$j $i] = g[$k $i], g[$k $i] = 0))
                    fi
                done
            done
            ;;
        l)
            for i in {0..3}; do
                for j in {3..0}; do
                    for ((k = j - 1; k >= 0; k--)) do
                        ((g[$i $j] == g[$i $k] && (g[$i $j] += g[$i $k], g[$i $k] = 0))) && break
                    done
                done
            done

            for i in {0..3}; do
                for j in {3..0}; do
                    if ((! g[$i $j])); then
                        for ((k = j - 1; k >= 0; k--)) do
                            ((g[$i $k])) && break
                        done

                        ((g[$i $j] = g[$i $k], g[$i $k] = 0))
                    fi
                done
            done
            ;;
        j)
            for i in {0..3}; do
                for j in {3..0}; do
                    for ((k = j - 1; k >= 0; k--)) do
                        ((g[$j $i] == g[$k $i] && (g[$j $i] += g[$k $i], g[$k $i] = 0))) && break
                    done
                done
            done

            for i in {0..3}; do
                for j in {3..0}; do
                    if ((! g[$j $i])); then
                        for ((k = j - 1; k >= 0; k--)) do
                            ((game[$k $i])) && break
                        done

                        ((g[$j $i] = g[$k $i], g[$k $i] = 0))
                    fi
                done
            done
    esac
}

# ---
# init
# ---

printf "\\e[2J"

declare -A g t

# fill the array
for i in {0..3}\ {0..3}; do
    ((g[$i] = 0))
done

new

display

# ---
# main
# ---

while read -r -rsn 1 key; do
    case $key in
        h|j|k|l)
            # save current state
            for i in "${!g[@]}"; do
                t[$i]=${g[$i]}
            done

            push "$key"

            check

            # compare with new state
            for i in "${!g[@]}"; do
                ((t[$i] != g[$i])) && { new; break; }
            done

            display
    esac
done
